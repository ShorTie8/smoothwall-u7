			     BASH PATCH REPORT
			     =================

Bash-Release:	4.1
Patch-ID:	bash41-001

Bug-Reported-by:	Yann Rouillard <yann@pleiades.fr.eu.org>
Bug-Reference-ID:	<4B44A410.4070107@pleiades.fr.eu.org>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2010-01/msg00018.html

Bug-Description:

A prototype for vsnprintf was incorrect, and caused compilation failures
on systems that did not have a suitable vsnprintf, but had a declaration in
one of the system header files.

Patch (apply with `patch -p0'):

*** bash-4.1-patched/builtins/printf.def	2009-11-20 15:31:23.000000000 -0500
--- builtins/printf.def	2010-01-07 08:50:06.000000000 -0500
***************
*** 173,177 ****
  
  #if !HAVE_VSNPRINTF
! extern int vsnprintf __P((char *, size_t, const char *, ...)) __attribute__((__format__ (printf, 3, 4)));
  #endif
  
--- 173,177 ----
  
  #if !HAVE_VSNPRINTF
! extern int vsnprintf __P((char *, size_t, const char *, va_list)) __attribute__((__format__ (printf, 3, 0)));
  #endif
  
*** bash-4.1-patched/patchlevel.h	2009-10-01 16:39:22.000000000 -0400
--- patchlevel.h	2010-01-14 09:38:08.000000000 -0500
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 0
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 1
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.1
Patch-ID:	bash41-002

Bug-Reported-by:	guillaume.outters@free.fr
Bug-Reference-ID:	<20100105230441.70D171AA7F52@asterix.local>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2010-01/msg00017.html

Bug-Description:

Bash-4.1/Readline-6.1 introduced a hook function that allows applications
to rewrite or modify filenames read from the file system before comparing
them with a word to be completed.  The converted filename, if it matches,
needs to be inserted into the line buffer, replacing the original contents.

This fixes a completion bug on Mac OS X involving filenames containing
UTF-8 characters.

Patch (apply with `patch -p0'):

*** bash-4.1-patched/lib/readline/complete.c	2009-11-29 18:39:30.000000000 -0500
--- lib/readline/complete.c	2010-01-06 08:30:23.000000000 -0500
***************
*** 2139,2143 ****
        if (filename_len == 0)
  	{
! 	  if (_rl_match_hidden_files == 0 && HIDDEN_FILE (entry->d_name))
  	    continue;
  
--- 2139,2143 ----
        if (filename_len == 0)
  	{
! 	  if (_rl_match_hidden_files == 0 && HIDDEN_FILE (convfn))
  	    continue;
  
***************
*** 2220,2224 ****
  	    }
  
! 	  strcpy (temp + dirlen, entry->d_name);
  	}
        else
--- 2220,2224 ----
  	    }
  
! 	  strcpy (temp + dirlen, convfn);
  	}
        else
*** bash-4.1-patched/patchlevel.h	2009-10-01 16:39:22.000000000 -0400
--- patchlevel.h	2010-01-14 09:38:08.000000000 -0500
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 1
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 2
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.1
Patch-ID:	bash41-003

Bug-Reported-by:	coyote@wariat.org.pl
Bug-Reference-ID:	<4b64a1f8.06e2660a.60af.4bfb@mx.google.com>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2010-01/msg00135.html

Bug-Description:

If command completion is attempted on a word with a quoted globbing
character (e.g., `*' or `?'), bash can reference a NULL pointer and
dump core.

Patch (apply with `patch -p0'):

*** bash-4.1-patched/bashline.c	2009-10-24 14:10:19.000000000 -0400
--- bashline.c	2010-01-30 21:53:49.000000000 -0500
***************
*** 1681,1685 ****
       characters in the common prefix are bad) will ever be returned on
       regular completion. */
!   if (glob_pattern_p (hint))
      {
        if (state == 0)
--- 1681,1685 ----
       characters in the common prefix are bad) will ever be returned on
       regular completion. */
!   if (globpat)
      {
        if (state == 0)
*** bash-4.1-patched/patchlevel.h	2009-10-01 16:39:22.000000000 -0400
--- patchlevel.h	2010-01-14 09:38:08.000000000 -0500
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 2
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 3
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.1
Patch-ID:	bash41-004

Bug-Reported-by:	Crestez Dan Leonard <cdleonard@gmail.com>
Bug-Reference-ID:	<1265592839.30682.21.camel@deskbox>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2010-02/msg00034.html

Bug-Description:

When running in Posix mode and executing a shell function without local
variables, bash will not propagate a variable in a special builtin's temporary
environment to have global scope.

Patch (apply with `patch -p0'):

*** bash-4.1-patched/variables.c	2009-11-03 14:13:58.000000000 -0500
--- variables.c	2010-02-08 17:36:18.000000000 -0500
***************
*** 3809,3812 ****
--- 3809,3817 ----
    if (tempvar_p (var) && (posixly_correct || (var->attributes & att_propagate)))
      {
+       /* Make sure we have a hash table to store the variable in while it is
+ 	 being propagated down to the global variables table.  Create one if
+ 	 we have to */
+       if ((vc_isfuncenv (shell_variables) || vc_istempenv (shell_variables)) && shell_variables->table == 0)
+ 	shell_variables->table = hash_create (0);
        /* XXX - should we set v->context here? */
        v = bind_variable_internal (var->name, value_cell (var), shell_variables->table, 0, 0);
*** bash-4.1-patched/patchlevel.h	2009-10-01 16:39:22.000000000 -0400
--- patchlevel.h	2010-01-14 09:38:08.000000000 -0500
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 3
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 4
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.1
Patch-ID:	bash41-005

Bug-Reported-by:	werner@suse.de
Bug-Reference-ID:	<201002251238.o1PCcYcg016893@boole.suse.de>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2010-02/msg00132.html

Bug-Description:

When the `read' builtin times out after the timeout specified with -t is
exceeded, it does not reset the flags that tell signal handlers to process
signals immediately instead of deferring their handling.  This can result
in unsafe functions being called from signal handlers, which can cause bash
to hang or dump core.

Patch (apply with `patch -p0'):

*** bash-4.1-patched/builtins/read.def	2009-10-08 11:35:46.000000000 -0400
--- builtins/read.def	2010-03-17 17:35:39.000000000 -0400
***************
*** 616,621 ****
      zsyncfd (fd);
  
-   interrupt_immediately--;
-   terminate_immediately--;
    discard_unwind_frame ("read_builtin");
  
--- 616,619 ----
***************
*** 624,627 ****
--- 622,628 ----
  assign_vars:
  
+   interrupt_immediately--;
+   terminate_immediately--;
+ 
  #if defined (ARRAY_VARS)
    /* If -a was given, take the string read, break it into a list of words,
*** bash-4.1-patched/patchlevel.h	2009-10-01 16:39:22.000000000 -0400
--- patchlevel.h	2010-01-14 09:38:08.000000000 -0500
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 4
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 5
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.1
Patch-ID:	bash41-006

Bug-Reported-by:	Mike Frysinger <vapier@gentoo.org>
Bug-Reference-ID:	<201003210155.56618.vapier@gentoo.org>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2010-03/msg00063.html

Bug-Description:

Bash did not correctly print/reproduce here documents attached to commands
inside compound commands such as for and while.  This affected the
execution of such commands inside a shell function when the function
definition is saved and later restored using `.' or `eval'.

Patch (apply with `patch -p0'):

*** bash-4.1-patched/print_cmd.c	2009-09-16 15:32:26.000000000 -0400
--- print_cmd.c	2010-03-22 21:15:30.000000000 -0400
***************
*** 114,117 ****
--- 114,123 ----
  #define CHECK_XTRACE_FP	xtrace_fp = (xtrace_fp ? xtrace_fp : stderr)
  
+ #define PRINT_DEFERRED_HEREDOCS(x) \
+   do { \
+     if (deferred_heredocs) \
+       print_deferred_heredocs (x); \
+   } while (0)
+ 
  /* Non-zero means the stuff being printed is inside of a function def. */
  static int inside_function_def;
***************
*** 561,571 ****
  {
    print_for_command_head (for_command);
- 
    cprintf (";");
    newline ("do\n");
    indentation += indentation_amount;
    make_command_string_internal (for_command->action);
    semicolon ();
    indentation -= indentation_amount;
    newline ("done");
  }
--- 566,578 ----
  {
    print_for_command_head (for_command);
    cprintf (";");
    newline ("do\n");
+ 
    indentation += indentation_amount;
    make_command_string_internal (for_command->action);
+   PRINT_DEFERRED_HEREDOCS ("");
    semicolon ();
    indentation -= indentation_amount;
+ 
    newline ("done");
  }
*** bash-4.1-patched/patchlevel.h	2009-10-01 16:39:22.000000000 -0400
--- patchlevel.h	2010-01-14 09:38:08.000000000 -0500
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 5
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 6
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.1
Patch-ID:	bash41-007

Bug-Reported-by:	Rob Robason <rob@robason.net>
Bug-Reference-ID:	<1269513145.22336.9.camel@home.robason.homelinux.net>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2010-03/msg00089.html

Bug-Description:

A typo caused bash to not honor a precision specification in a printf
format.

Patch (apply with `patch -p0'):

*** bash-4.1-patched/builtins/printf.def	2010-01-18 10:50:22.000000000 -0500
--- builtins/printf.def	2010-03-25 09:40:56.000000000 -0400
***************
*** 118,122 ****
        nw = vflag ? vbprintf (f, fieldwidth, func) : printf (f, fieldwidth, func); \
      else if (have_precision) \
!       nw = vflag ? vbprintf (f, precision, func) : printf (f, fieldwidth, func); \
      else \
        nw = vflag ? vbprintf (f, func) : printf (f, func); \
--- 118,122 ----
        nw = vflag ? vbprintf (f, fieldwidth, func) : printf (f, fieldwidth, func); \
      else if (have_precision) \
!       nw = vflag ? vbprintf (f, precision, func) : printf (f, precision, func); \
      else \
        nw = vflag ? vbprintf (f, func) : printf (f, func); \
*** bash-4.1-patched/patchlevel.h	2009-10-01 16:39:22.000000000 -0400
--- patchlevel.h	2010-01-14 09:38:08.000000000 -0500
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 6
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 7
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.1
Patch-ID:	bash41-008

Bug-Reported-by:	Dennis van Dok <dvandok@gmail.com>
Bug-Reference-ID:	<4BBF2501.5050703@gmail.com>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2010-04/msg00038.html

Bug-Description:

When declaring an associative array and implicitly assigning a value
to element "0", bash does not correctly allocate memory, leading to
a segmentation violation when that element or the array itself is
unset.

Patch (apply with `patch -p0'):

*** bash-4.1-patched/builtins/declare.def	2009-11-25 19:42:00.000000000 -0500
--- builtins/declare.def	2010-05-30 18:25:21.000000000 -0400
***************
*** 513,517 ****
  	      /* let bind_{array,assoc}_variable take care of this. */
  	      if (assoc_p (var))
! 		bind_assoc_variable (var, name, "0", value, aflags);
  	      else
  		bind_array_variable (name, 0, value, aflags);
--- 519,523 ----
  	      /* let bind_{array,assoc}_variable take care of this. */
  	      if (assoc_p (var))
! 		bind_assoc_variable (var, name, savestring ("0"), value, aflags);
  	      else
  		bind_array_variable (name, 0, value, aflags);
*** bash-4.1-patched/patchlevel.h	2009-10-01 16:39:22.000000000 -0400
--- patchlevel.h	2010-01-14 09:38:08.000000000 -0500
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 7
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 8
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.1
Patch-ID:	bash41-009

Bug-Reported-by:	Tomas Trnka <tomastrnka@gmx.com>
Bug-Reference-ID:	<201003242030.02166.tomastrnka@gmx.com>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2010-03/msg00090.html

Bug-Description:

An arriving SIGCHLD will interrupt `slow' system calls such as write(2) to
or read(2) from a terminal.  This results in an error message and truncated
input or output.

Patch (apply with `patch -p0'):

*** bash-4.1-patched/sig.c	Fri Aug 14 16:31:52 2009
--- sig.c	Fri Mar 26 22:34:11 2010
***************
*** 655,660 ****
--- 655,663 ----
      act.sa_flags |= SA_INTERRUPT;	/* XXX */
    else
      act.sa_flags |= SA_RESTART;		/* XXX */
+ #else
+   if (sig == SIGCHLD)
+     act.sa_flags |= SA_RESTART;
  #endif
    sigemptyset (&act.sa_mask);
    sigemptyset (&oact.sa_mask);
*** bash-4.1-patched/patchlevel.h	2009-10-01 16:39:22.000000000 -0400
--- patchlevel.h	2010-01-14 09:38:08.000000000 -0500
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 8
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 9
  
  #endif /* _PATCHLEVEL_H_ */

			     BASH PATCH REPORT
			     =================

Bash-Release:	4.1
Patch-ID:	bash41-010

Bug-Reported-by:	Stephane Jourdois <sjourdois@gmail.com>
Bug-Reference-ID:	<AANLkTimbh1t2BmCjnCgACpEidArJMBIEtr30Vv3VzHxf@mail.gmail.com>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2010-05/msg00165.html

Bug-Description:

The expansion of the \W prompt string escape sequence incorrectly used
strcpy to copy overlapping strings.  Only memmove works in this case.

Patch (apply with `patch -p0'):

*** bash-4.1-patched/parse.y	2009-12-30 12:51:42.000000000 -0500
--- parse.y	2011-02-24 16:40:48.000000000 -0500
***************
*** 5153,5157 ****
  			t = strrchr (t_string, '/');
  			if (t)
! 			  strcpy (t_string, t + 1);
  		      }
  		  }
--- 5153,5157 ----
  			t = strrchr (t_string, '/');
  			if (t)
! 			  memmove (t_string, t + 1, strlen (t));
  		      }
  		  }
*** bash-4.1-patched/y.tab.c	2009-12-30 12:52:02.000000000 -0500
--- y.tab.c	2011-02-24 16:50:27.000000000 -0500
***************
*** 7482,7486 ****
  			t = strrchr (t_string, '/');
  			if (t)
! 			  strcpy (t_string, t + 1);
  		      }
  		  }
--- 7482,7486 ----
  			t = strrchr (t_string, '/');
  			if (t)
! 			  memmove (t_string, t + 1, strlen (t));
  		      }
  		  }
***************
*** 8244,8246 ****
  }
  #endif /* HANDLE_MULTIBYTE */
- 
--- 8244,8245 ----
*** bash-4.1-patched/patchlevel.h	2009-10-01 16:39:22.000000000 -0400
--- patchlevel.h	2010-01-14 09:38:08.000000000 -0500
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 9
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 10
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.1
Patch-ID:	bash41-011

Bug-Reported-by:	<piuma@piumalab.org>
Bug-Reference-ID:	<4DAAC0DB.7060606@piumalab.org>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2011-04/msg00075.html

Bug-Description:

Under certain circumstances, running `fc -l' two times in succession with a
relative history offset at the end of the history will result in an incorrect
calculation of the last history entry and a seg fault.

Patch (apply with `patch -p0'):

*** bash-4.1-patched/builtins/fc.def	2009-03-21 14:03:43.000000000 -0400
--- builtins/fc.def	2011-04-19 15:46:17.000000000 -0400
***************
*** 304,307 ****
--- 304,317 ----
    last_hist = i - rh - hist_last_line_added;
  
+   /* XXX */
+   if (i == last_hist && hlist[last_hist] == 0)
+     while (last_hist >= 0 && hlist[last_hist] == 0)
+       last_hist--;
+   if (last_hist < 0)
+     {
+       sh_erange ((char *)NULL, _("history specification"));
+       return (EXECUTION_FAILURE);
+     }
+ 
    if (list)
      {
***************
*** 466,470 ****
  {
    int sign, n, clen, rh;
!   register int i, j;
    register char *s;
  
--- 476,480 ----
  {
    int sign, n, clen, rh;
!   register int i, j, last_hist;
    register char *s;
  
***************
*** 486,490 ****
       calculation as if it were on. */
    rh = remember_on_history || ((subshell_environment & SUBSHELL_COMSUB) && enable_history_list);
!   i -= rh + hist_last_line_added;
  
    /* No specification defaults to most recent command. */
--- 496,508 ----
       calculation as if it were on. */
    rh = remember_on_history || ((subshell_environment & SUBSHELL_COMSUB) && enable_history_list);
!   last_hist = i - rh - hist_last_line_added;
! 
!   if (i == last_hist && hlist[last_hist] == 0)
!     while (last_hist >= 0 && hlist[last_hist] == 0)
!       last_hist--;
!   if (last_hist < 0)
!     return (-1);
! 
!   i = last_hist;
  
    /* No specification defaults to most recent command. */
*** bash-4.1-patched/patchlevel.h	2009-10-01 16:39:22.000000000 -0400
--- patchlevel.h	2010-01-14 09:38:08.000000000 -0500
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 10
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 11
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	4.1
Patch-ID:	bash41-012

Bug-Reported-by:	Stephane Chazelas <stephane.chazelas@gmail.com>
Bug-Reference-ID:
Bug-Reference-URL:

Bug-Description:

Under certain circumstances, bash will execute user code while processing the
environment for exported function definitions.

Patch (apply with `patch -p0'):

*** bash-4.1.11/builtins/common.h	2009-12-22 16:30:42.000000000 -0500
--- builtins/common.h	2014-09-16 19:27:38.000000000 -0400
***************
*** 36,39 ****
--- 36,41 ----
  
  /* Flags for describe_command, shared between type.def and command.def */
+ #define SEVAL_FUNCDEF	0x080		/* only allow function definitions */
+ #define SEVAL_ONECMD	0x100		/* only allow a single command */
  #define CDESC_ALL		0x001	/* type -a */
  #define CDESC_SHORTDESC		0x002	/* command -V */
*** bash-4.1.11/builtins/evalstring.c	2009-10-17 21:18:50.000000000 -0400
--- builtins/evalstring.c	2014-09-16 19:27:38.000000000 -0400
***************
*** 262,265 ****
--- 262,273 ----
  	      struct fd_bitmap *bitmap;
  
+ 	      if ((flags & SEVAL_FUNCDEF) && command->type != cm_function_def)
+ 		{
+ 		  internal_warning ("%s: ignoring function definition attempt", from_file);
+ 		  should_jump_to_top_level = 0;
+ 		  last_result = last_command_exit_value = EX_BADUSAGE;
+ 		  break;
+ 		}
+ 
  	      bitmap = new_fd_bitmap (FD_BITMAP_SIZE);
  	      begin_unwind_frame ("pe_dispose");
***************
*** 322,325 ****
--- 330,336 ----
  	      dispose_fd_bitmap (bitmap);
  	      discard_unwind_frame ("pe_dispose");
+ 
+ 	      if (flags & SEVAL_ONECMD)
+ 		break;
  	    }
  	}
*** bash-4.1.11/variables.c	2010-03-26 12:15:39.000000000 -0400
--- variables.c	2014-09-16 19:27:38.000000000 -0400
***************
*** 348,357 ****
  	  strcpy (temp_string + char_index + 1, string);
  
! 	  parse_and_execute (temp_string, name, SEVAL_NONINT|SEVAL_NOHIST);
! 
! 	  /* Ancient backwards compatibility.  Old versions of bash exported
! 	     functions like name()=() {...} */
! 	  if (name[char_index - 1] == ')' && name[char_index - 2] == '(')
! 	    name[char_index - 2] = '\0';
  
  	  if (temp_var = find_function (name))
--- 348,355 ----
  	  strcpy (temp_string + char_index + 1, string);
  
! 	  /* Don't import function names that are invalid identifiers from the
! 	     environment. */
! 	  if (legal_identifier (name))
! 	    parse_and_execute (temp_string, name, SEVAL_NONINT|SEVAL_NOHIST|SEVAL_FUNCDEF|SEVAL_ONECMD);
  
  	  if (temp_var = find_function (name))
***************
*** 362,369 ****
  	  else
  	    report_error (_("error importing function definition for `%s'"), name);
- 
- 	  /* ( */
- 	  if (name[char_index - 1] == ')' && name[char_index - 2] == '\0')
- 	    name[char_index - 2] = '(';		/* ) */
  	}
  #if defined (ARRAY_VARS)
--- 360,363 ----
*** bash-4.1-patched/patchlevel.h	2009-10-01 16:39:22.000000000 -0400
--- patchlevel.h	2010-01-14 09:38:08.000000000 -0500
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 11
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 12
  
  #endif /* _PATCHLEVEL_H_ */
