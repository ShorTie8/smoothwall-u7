*** bash-2.05b/lib/readline/bind.c	Thu Jan 24 11:15:52 2002
--- lib/readline/bind.c	Wed Jul 31 09:11:18 2002
***************
*** 312,316 ****
  	     and the function bound  to `a' to be executed when the user
  	     types `abx', leaving `bx' in the input queue. */
! 	  if (k.function /* && k.type == ISFUNC */)
  	    {
  	      map[ANYOTHERKEY] = k;
--- 312,316 ----
  	     and the function bound  to `a' to be executed when the user
  	     types `abx', leaving `bx' in the input queue. */
! 	  if (k.function && ((k.type == ISFUNC && k.function != rl_do_lowercase_version) || k.type == ISMACR))
  	    {
  	      map[ANYOTHERKEY] = k;

*** bash-2.05b/lib/readline/readline.c	Wed Mar 13 17:10:46 2002
--- lib/readline/readline.c	Tue Jul 30 17:46:44 2002
***************
*** 685,688 ****
--- 685,689 ----
  #if defined (VI_MODE)
    if (rl_editing_mode == vi_mode && _rl_keymap == vi_movement_keymap &&
+       key != ANYOTHERKEY &&
        _rl_vi_textmod_command (key))
      _rl_vi_set_last (key, rl_numeric_arg, rl_arg_sign);


*** bash-2.05b/bashline.c	Tue May  7 15:52:42 2002
--- bashline.c	Sat Aug  3 11:40:16 2002
***************
*** 1045,1049 ****
--- 1045,1052 ----
        else
  	{
+ #define CMD_IS_DIR(x)	(absolute_pathname(x) == 0 && *(x) != '~' && test_for_directory (x))
+ 
  	  matches = rl_completion_matches (text, command_word_completion_function);
+ 
  	  /* If we are attempting command completion and nothing matches, we
  	     do not want readline to perform filename completion for us.  We
***************
*** 1053,1057 ****
  	  if (matches == (char **)NULL)
  	    rl_ignore_some_completions_function = bash_ignore_filenames;
! 	  else if (matches[1] == 0 && *matches[0] != '/')
  	    /* Turn off rl_filename_completion_desired so readline doesn't
  	       append a slash if there is a directory with the same name
--- 1056,1060 ----
  	  if (matches == (char **)NULL)
  	    rl_ignore_some_completions_function = bash_ignore_filenames;
! 	  else if (matches[1] == 0 && CMD_IS_DIR(matches[0]))
  	    /* Turn off rl_filename_completion_desired so readline doesn't
  	       append a slash if there is a directory with the same name
***************
*** 1062,1066 ****
  	       conflict. */
  	    rl_filename_completion_desired = 0;
! 	  else if (matches[0] && matches[1] && STREQ (matches[0], matches[1]) && *matches[0] != '/')
  	    /* There are multiple instances of the same match (duplicate
  	       completions haven't yet been removed).  In this case, all of
--- 1065,1069 ----
  	       conflict. */
  	    rl_filename_completion_desired = 0;
! 	  else if (matches[0] && matches[1] && STREQ (matches[0], matches[1]) && CMD_IS_DIR (matches[0]))
  	    /* There are multiple instances of the same match (duplicate
  	       completions haven't yet been removed).  In this case, all of

*** bash-2.05b/subst.c	Mon Jun 24 07:59:45 2002
--- subst.c	Sat Aug 17 17:28:46 2002
***************
*** 1639,1647 ****
  /* This performs word splitting and quoted null character removal on
     STRING. */
! #if 0
! #define issep(c)	((separators)[1] ? (member ((c), separators)) : (c) == (separators)[0])
! #else
! #define issep(c)	((separators)[1] ? isifs(c) : (c) == (separators)[0])
! #endif
  
  WORD_LIST *
--- 1639,1646 ----
  /* This performs word splitting and quoted null character removal on
     STRING. */
! #define issep(c) \
! 	(((separators)[0]) ? ((separators)[1] ? isifs(c) \
! 					      : (c) == (separators)[0]) \
! 			   : 0)
  
  WORD_LIST *



*** bash-2.05b/lib/readline/mbutil.c	Tue Jun  4 11:54:29 2002
--- lib/readline/mbutil.c	Mon Aug  5 11:20:39 2002
***************
*** 206,210 ****
      {
        /* shorted to compose multibyte char */
!       memset (ps, 0, sizeof(mbstate_t));
        return -2;
      }
--- 206,211 ----
      {
        /* shorted to compose multibyte char */
!       if (ps)
! 	memset (ps, 0, sizeof(mbstate_t));
        return -2;
      }
***************
*** 213,217 ****
        /* invalid to compose multibyte char */
        /* initialize the conversion state */
!       memset (ps, 0, sizeof(mbstate_t));
        return -1;
      }
--- 214,219 ----
        /* invalid to compose multibyte char */
        /* initialize the conversion state */
!       if (ps)
! 	memset (ps, 0, sizeof(mbstate_t));
        return -1;
      }
***************
*** 226,232 ****
  int
  _rl_compare_chars (buf1, pos1, ps1, buf2, pos2, ps2)
!      char *buf1, *buf2;
!      mbstate_t *ps1, *ps2;
!      int pos1, pos2;
  {
    int i, w1, w2;
--- 228,237 ----
  int
  _rl_compare_chars (buf1, pos1, ps1, buf2, pos2, ps2)
!      char *buf1;
!      int pos1;
!      mbstate_t *ps1;
!      char *buf2;
!      int pos2;
!      mbstate_t *ps2;
  {
    int i, w1, w2;
***************
*** 277,282 ****
  	  /* clear the state of the byte sequence, because
  	     in this case effect of mbstate is undefined  */
! 	  memset (ps, 0, sizeof (mbstate_t));
  	}
        else
  	pos += tmp;
--- 282,290 ----
  	  /* clear the state of the byte sequence, because
  	     in this case effect of mbstate is undefined  */
! 	  if (ps)
! 	    memset (ps, 0, sizeof (mbstate_t));
  	}
+       else if (tmp == 0)
+ 	pos++;
        else
  	pos += tmp;

*** bash-2.05b/lib/readline/display.c	Tue Jun  4 10:54:47 2002
--- lib/readline/display.c	Fri Sep 13 16:22:57 2002
***************
*** 71,75 ****
  
  #if defined (HANDLE_MULTIBYTE)
! static int _rl_col_width PARAMS((char *, int, int));
  static int *_rl_wrapped_line;
  #else
--- 71,75 ----
  
  #if defined (HANDLE_MULTIBYTE)
! static int _rl_col_width PARAMS((const char *, int, int));
  static int *_rl_wrapped_line;
  #else
***************
*** 1349,1355 ****
  	      _rl_output_some_chars (nfd + lendiff, temp - lendiff);
  #if 0
- 	      _rl_last_c_pos += _rl_col_width (nfd+lendiff, 0, temp-lendiff) - col_lendiff;
- #else
  	      _rl_last_c_pos += _rl_col_width (nfd+lendiff, 0, temp-col_lendiff);
  #endif
  	    }
--- 1349,1355 ----
  	      _rl_output_some_chars (nfd + lendiff, temp - lendiff);
  #if 0
  	      _rl_last_c_pos += _rl_col_width (nfd+lendiff, 0, temp-col_lendiff);
+ #else
+ 	      _rl_last_c_pos += _rl_col_width (nfd+lendiff, 0, temp-lendiff);
  #endif
  	    }
***************
*** 1511,1516 ****
    /* If we have multibyte characters, NEW is indexed by the buffer point in
       a multibyte string, but _rl_last_c_pos is the display position.  In
!      this case, NEW's display position is not obvious. */
!   if ((MB_CUR_MAX == 1 || rl_byte_oriented ) && _rl_last_c_pos == new) return;
  #else
    if (_rl_last_c_pos == new) return;
--- 1511,1523 ----
    /* If we have multibyte characters, NEW is indexed by the buffer point in
       a multibyte string, but _rl_last_c_pos is the display position.  In
!      this case, NEW's display position is not obvious and must be
!      calculated. */
!   if (MB_CUR_MAX == 1 || rl_byte_oriented)
!     {
!       if (_rl_last_c_pos == new)
! 	return;
!     }
!   else if (_rl_last_c_pos == _rl_col_width (data, 0, new))
!     return;
  #else
    if (_rl_last_c_pos == new) return;
***************
*** 1595,1603 ****
      {
        if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
! 	{
! 	  tputs (_rl_term_cr, 1, _rl_output_character_function);
! 	  for (i = 0; i < new; i++)
! 	    putc (data[i], rl_outstream);
! 	}
        else
  	_rl_backspace (_rl_last_c_pos - new);
--- 1602,1606 ----
      {
        if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
! 	_rl_backspace (_rl_last_c_pos - _rl_col_width (data, 0, new));
        else
  	_rl_backspace (_rl_last_c_pos - new);
***************
*** 2118,2122 ****
  static int
  _rl_col_width (str, start, end)
!      char *str;
       int start, end;
  {
--- 2121,2125 ----
  static int
  _rl_col_width (str, start, end)
!      const char *str;
       int start, end;
  {
***************
*** 2194,2196 ****
  }
  #endif /* HANDLE_MULTIBYTE */
- 	  
--- 2197,2198 ----

*** bash-2.05b/lib/readline/vi_mode.c	Thu May 23 13:27:58 2002
--- lib/readline/vi_mode.c	Tue Feb  4 15:11:07 2003
***************
*** 681,685 ****
  {
    wchar_t wc;
!   char mb[MB_LEN_MAX];
    mbstate_t ps;
  
--- 681,686 ----
  {
    wchar_t wc;
!   char mb[MB_LEN_MAX+1];
!   int mblen;
    mbstate_t ps;
  
***************
*** 704,708 ****
        if (wc)
  	{
! 	  wctomb (mb, wc);
  	  rl_begin_undo_group ();
  	  rl_delete (1, 0);
--- 705,711 ----
        if (wc)
  	{
! 	  mblen = wctomb (mb, wc);
! 	  if (mblen >= 0)
! 	    mb[mblen] = '\0';
  	  rl_begin_undo_group ();
  	  rl_delete (1, 0);

*** bash-2.05b.07/builtins/common.h	2002-05-10 12:25:08.000000000 -0400
--- builtins/common.h	2014-09-25 10:18:20.000000000 -0400
***************
*** 33,36 ****
--- 33,38 ----
  
  /* Flags for describe_command, shared between type.def and command.def */
+ #define SEVAL_FUNCDEF	0x080		/* only allow function definitions */
+ #define SEVAL_ONECMD	0x100		/* only allow a single command */
  #define CDESC_ALL		0x001	/* type -a */
  #define CDESC_SHORTDESC		0x002	/* command -V */
*** bash-2.05b.07/builtins/evalstring.c	2002-04-04 13:38:50.000000000 -0500
--- builtins/evalstring.c	2014-09-25 10:18:20.000000000 -0400
***************
*** 205,208 ****
--- 205,216 ----
  	      struct fd_bitmap *bitmap;
  
+ 	      if ((flags & SEVAL_FUNCDEF) && command->type != cm_function_def)
+ 		{
+ 		  internal_warning ("%s: ignoring function definition attempt", from_file);
+ 		  should_jump_to_top_level = 0;
+ 		  last_result = last_command_exit_value = EX_BADUSAGE;
+ 		  break;
+ 		}
+ 
  	      bitmap = new_fd_bitmap (FD_BITMAP_SIZE);
  	      begin_unwind_frame ("pe_dispose");
***************
*** 256,259 ****
--- 264,270 ----
  	      dispose_fd_bitmap (bitmap);
  	      discard_unwind_frame ("pe_dispose");
+ 
+ 	      if (flags & SEVAL_ONECMD)
+ 		break;
  	    }
  	}
*** bash-2.05b.07/variables.c	2002-06-25 09:43:33.000000000 -0400
--- variables.c	2014-09-25 10:18:20.000000000 -0400
***************
*** 270,279 ****
  	  strcpy (temp_string + char_index + 1, string);
  
! 	  parse_and_execute (temp_string, name, SEVAL_NONINT|SEVAL_NOHIST);
! 
! 	  /* Ancient backwards compatibility.  Old versions of bash exported
! 	     functions like name()=() {...} */
! 	  if (name[char_index - 1] == ')' && name[char_index - 2] == '(')
! 	    name[char_index - 2] = '\0';
  
  	  if (temp_var = find_function (name))
--- 270,277 ----
  	  strcpy (temp_string + char_index + 1, string);
  
! 	  /* Don't import function names that are invalid identifiers from the
! 	     environment. */
! 	  if (legal_identifier (name))
! 	    parse_and_execute (temp_string, name, SEVAL_NONINT|SEVAL_NOHIST|SEVAL_FUNCDEF|SEVAL_ONECMD);
  
  	  if (temp_var = find_function (name))
***************
*** 284,291 ****
  	  else
  	    report_error ("error importing function definition for `%s'", name);
- 
- 	  /* ( */
- 	  if (name[char_index - 1] == ')' && name[char_index - 2] == '\0')
- 	    name[char_index - 2] = '(';		/* ) */
  	}
  #if defined (ARRAY_VARS)
--- 282,285 ----

*** bash-2.05b.08/parse.y	2002-05-21 11:57:30.000000000 -0400
--- parse.y	2014-09-25 16:46:51.000000000 -0400
***************
*** 2356,2359 ****
--- 2356,2361 ----
    word_desc_to_read = (WORD_DESC *)NULL;
  
+   eol_ungetc_lookahead = 0;
+ 
    last_read_token = '\n';
    token_to_read = '\n';
