#!/bin/bash

########################################################################
# Begin $rc_base/init.d/functions
#
# Description : Run Level Control Functions
#
# Authors     : Gerard Beekmans - gerard@linuxfromscratch.org
#
# Version     : 00.00
#
# Notes       : With code based on Matthias Benkmann's simpleinit-msb
#		http://winterdrache.de/linux/newboot/index.html
#
########################################################################

## Environmental setup
# Setup default values for environment
umask 022
export PATH="/bin:/usr/bin:/sbin:/usr/sbin"

# Signal sent to running processes to refresh their configuration
RELOADSIG="HUP"

# Number of seconds between STOPSIG and FALLBACK when stopping processes
KILLDELAY="3"

## Screen Dimensions
# Find current screen size
if [ -z "${COLUMNS}" ]; then
	COLUMNS=$(stty size)
	COLUMNS=${COLUMNS##* }
fi

# When using remote connections, such as a serial port, stty size returns 0
if [ "${COLUMNS}" = "0" ]; then 
	COLUMNS=80
fi

## Measurements for positioning result messages
COL=$((${COLUMNS} - 8))
WCOL=$((${COL} - 2))

## Provide an echo that supports -e and -n
# If formatting is needed, $ECHO should be used
case "`echo -e -n test`" in
	-[en]*)
		ECHO=/bin/echo
		;;
	*)
		ECHO=echo
		;;
esac

## Set Cursor Position Commands, used via $ECHO
SET_COL="\\033[${COL}G"      # at the $COL char
SET_WCOL="\\033[${WCOL}G"    # at the $WCOL char
CURS_UP="\\033[1A\\033[0G"   # Up one line, at the 0'th char

## Set color commands, used via $ECHO
# Please consult `man console_codes for more information
# under the "ECMA-48 Set Graphics Rendition" section
#
# Warning: when switching from a 8bit to a 9bit font,
# the linux console will reinterpret the bold (1;) to
# the top 256 glyphs of the 9bit font.  This does
# not affect framebuffer consoles
NORMAL="\\033[0;39m"         # Standard console grey
SUCCESS="\\033[1;32m"        # Success is green
WARNING="\\033[1;33m"        # Warnings are yellow
FAILURE="\\033[1;31m"        # Failures are red
INFO="\\033[1;36m"           # Information is light cyan
BRACKET="\\033[1;34m"        # Brackets are blue

STRING_LENGTH="0"   # the length of the current message

#*******************************************************************************
# Function - boot_mesg()
#
# Purpose:      Sending information from bootup scripts to the console
#
# Inputs:       $1 is the message
#               $2 is the colorcode for the console
#
# Outputs:      Standard Output
#
# Dependencies: - sed for parsing strings.
#	        - grep for counting string length.
#               
# Todo:         
#*******************************************************************************
boot_mesg()
{
	local ECHOPARM=""

	while true
	do
		case "${1}" in
			-n)
				ECHOPARM=" -n "
				shift 1
				;;
			-*)
				echo "Unknown Option: ${1}"
				return 1
				;;
			*)
				break
				;;
		esac
	done

	## Figure out the length of what is to be printed to be used
	## for warning messages. 
	STRING_LENGTH=$((${#1} + 1))

	# Print the message to the screen
	${ECHO} ${ECHOPARM} -e "${2}${1}"
	
}

boot_mesg_flush()
{
	# Reset STRING_LENGTH for next message
	STRING_LENGTH="0"
}

echo_ok()
{
	${ECHO} -n -e "${CURS_UP}${SET_COL}${BRACKET}[${SUCCESS}  OK  ${BRACKET}]"
	${ECHO} -e "${NORMAL}"
        boot_mesg_flush
}

echo_failure()
{
	${ECHO} -n -e "${CURS_UP}${SET_COL}${BRACKET}[${FAILURE} FAIL ${BRACKET}]"
	${ECHO} -e "${NORMAL}"
        boot_mesg_flush
}

echo_warning()
{
	${ECHO} -n -e "${CURS_UP}${SET_COL}${BRACKET}[${WARNING} WARN ${BRACKET}]"
	${ECHO} -e "${NORMAL}"
        boot_mesg_flush
}

evaluate_retval()
{
	error_value="${?}"

	if [ ${error_value} = 0 ]; then
		echo_ok
	else
		echo_failure
	fi

	# This prevents the 'An Unexpected Error Has Occurred' from trivial
	# errors.
	return 0
}

print_status()
{
	if [ "${#}" = "0" ]; then
		echo "Usage: ${0} {success|warning|failure}"
		return 1
	fi

	case "${1}" in

		success)
			echo_ok
			;;

		warning)
			# Leave this extra case in because old scripts
			# may call it this way.
			case "${2}" in
				running)
					${ECHO} -e -n "${CURS_UP}"
					${ECHO} -e -n "\\033[${STRING_LENGTH}G   "
					boot_mesg "Already running." ${WARNING}
					echo_warning
					;;
				not_running)
					${ECHO} -e -n "${CURS_UP}"
					${ECHO} -e -n "\\033[${STRING_LENGTH}G   "
					boot_mesg "Not running." ${WARNING}
					echo_warning
					;;
				not_available)
					${ECHO} -e -n "${CURS_UP}"
					${ECHO} -e -n "\\033[${STRING_LENGTH}G   "
					boot_mesg "Not available." ${WARNING}
					echo_warning
					;;
				*)
					# This is how it is supposed to
					# be called
					echo_warning
					;;
			esac
		;;

		failure)
			echo_failure
		;;

	esac

}

# The below functions are documented in the LSB-generic 2.1.0

#*******************************************************************************
# Function - pidofproc [-s] [-p pidfile] pathname
#
# Purpose: This function returns one or more pid(s) for a particular daemon
#
# Inputs: -p pidfile, use the specified pidfile instead of pidof
#         pathname, path to the specified program
#
# Outputs: return 0 - Success, pid's in stdout
#          return 1 - Program is dead, pidfile exists
#          return 2 - Invalid or excessive number of arguments, 
#                     warning in stdout
#          return 3 - Program is not running
#
# Dependencies: pidof, echo, head
#
# Todo: Remove dependency on head
#       This replaces getpids
#       Test changes to pidof
#
#*******************************************************************************
pidofproc()
{
	local pidfile=""
	local lpids=""
	local silent=""
	pidlist=""
	while true
	do
		case "${1}" in
			-p)
				pidfile="${2}"
				shift 2
				;;

			-s)
				# Added for legacy opperation of getpids
				# eliminates several '> /dev/null'
				silent="1"
				shift 1
				;;
			-*)
				log_failure_msg "Unknown Option: ${1}"
				return 2
				;;
			*)
				break
				;;
		esac
	done

	if [ "${#}" != "1" ]; then
		shift 1
		log_failure_msg "Usage: pidofproc [-s] [-p pidfile] pathname"
		return 2
	fi

	if [ -n "${pidfile}" ]; then
		if [ ! -r "${pidfile}" ]; then
			return 3 # Program is not running
		fi

		lpids=`head -n 1 ${pidfile}`
		for pid in ${lpids}
		do
			if [ "${pid}" -ne "$$" -a "${pid}" -ne "${PPID}" ]; then
				kill -0 "${pid}" 2>/dev/null &&
				pidlist="${pidlist} ${pid}"
			fi
			
			if [ "${silent}" != "1" ]; then
				echo "${pidlist}"
			fi

			test -z "${pidlist}" && 
			# Program is dead, pidfile exists
			return 1
			# else
			return 0
		done

	else
		pidlist=`pidof -o $$ -o $PPID -x "$1"`
		if [ "${silent}" != "1" ]; then
			echo "${pidlist}"
		fi

		# Get provide correct running status
		if [ -n "${pidlist}" ]; then
			return 0
		else
			return 3
		fi

	fi

	if [ "$?" != "0" ]; then
		return 3 # Program is not running
	fi
}

#*******************************************************************************
# Function - log_failure_msg "message"
#
# Purpose: Print a failure message
#
# Inputs: $@ - Message
#
# Outputs: Text output to screen
#
# Dependencies: echo
#
# Todo: logging
#
#*******************************************************************************
log_failure_msg() {
	${ECHO} -n -e "${BOOTMESG_PREFIX}${@}"
	${ECHO} -e "${SET_COL}""${BRACKET}""[""${FAILURE}"" FAIL ""${BRACKET}""]""${NORMAL}"
	return 0
}

#*******************************************************************************
# Function - log_warning_msg "message"
#
# Purpose: print a warning message
#
# Inputs: $@ - Message
#
# Outputs: Text output to screen
#
# Dependencies: echo
#
# Todo: logging
#
#*******************************************************************************
log_warning_msg() {
	${ECHO} -n -e "${BOOTMESG_PREFIX}${@}"
	${ECHO} -e "${SET_COL}""${BRACKET}""[""${WARNING}"" WARN ""${BRACKET}""]""${NORMAL}"
	return 0
}

# End $rc_base/init.d/functions

boot_mesg "Populating /dev with device nodes..."
if ! grep -q '[[:space:]]sysfs' /proc/mounts; then
        echo_failure
        boot_mesg -n "FAILURE:\n\nUnable to create" ${FAILURE}
        boot_mesg -n " devices without a SysFS filesystem"
        boot_mesg -n "\n\nAfter you press Enter, this system"
        boot_mesg -n " will be halted and powered off."
        boot_mesg -n "\n\nPress Enter to continue..." ${INFO}
        boot_mesg "" ${NORMAL}
        read ENTER
        /sbin/halt -f
fi

# Mount a temporary file system over /dev, so that any devices
# made or removed during this boot don't affect the next one.
# The reason we don't write to mtab is because we don't ever
# want /dev to be unavailable (such as by `umount -a').
mount -n -t tmpfs udev /dev -o size=10M,mode=0755

if [ ${?} != 0 ]; then
        echo_failure
        boot_mesg -n "FAILURE:\n\nCannot mount a tmpfs" ${FAILURE}
        boot_mesg -n " onto /dev, this system will be halted."
        boot_mesg -n "\n\nAfter you press Enter, this system"
        boot_mesg -n " will be halted and powered off."
        boot_mesg -n "\n\nPress Enter to continue..." ${INFO}
        boot_mesg "" ${NORMAL}
        read ENTER
        /sbin/halt -f
fi

# Udev handles uevents itself, so we don't need to have
# the kernel call out to any binary in response to them
echo > /proc/sys/kernel/hotplug

# Copy static device nodes to /dev
cp -a /lib/udev/devices/* /dev

# Start the udev daemon to continually watch for, and act on,
# uevents
/sbin/udevd --daemon

# Now traverse /sys in order to "coldplug" devices that have
# already been discovered
/sbin/udevadm trigger

# Now wait for udevd to process the uevents we triggered
/sbin/udevadm settle
evaluate_retval
